# **Collisions: When Two Keys Want the Same Spot!** üöóüí•

## **What is a Collision?**
When **two different keys** produce the **same hash value** (same array index).

Think of it like:
- Two students with same student ID number
- Two cars with same license plate
- Two people with same locker number

---

## **VISUAL EXAMPLE:**

```python
# Simple hash function: "length of word % 3"
def simple_hash(word):
    return len(word) % 3

print(simple_hash("cat"))   # 3 % 3 = 0
print(simple_hash("dog"))   # 3 % 3 = 0 ‚Üê COLLISION! Both want index 0!
print(simple_hash("elephant"))  # 8 % 3 = 2
```

**Hash Table:**
```
Index 0: cat? or dog? ‚Üê Both want this spot!
Index 1: (empty)
Index 2: elephant
```

---

## **WHY COLLISIONS HAPPEN:**

### **1. Fixed Array Size**
We have 1000 keys but only 10 buckets!
```
Array size = 10
Keys = ["A", "B", "C", ..., "Z", "AA", "BB"...]
Even with perfect hash, some will share buckets!
```

### **2. Hash Function Limitations**
No perfect hash function for all possible inputs!

---

## **TYPES OF COLLISION RESOLUTION:**

## **1. SEPARATE CHAINING (Most Common)**

### **How it works:**
Each bucket contains a **linked list** (or list) of entries

```python
# Visual representation:
Hash Table:
Index 0: [("cat", "meow")] ‚Üí [("dog", "woof")] ‚Üí None
Index 1: [("bird", "tweet")] ‚Üí None
Index 2: [("elephant", "trumpet")] ‚Üí None
```

### **Python Example:**
```python
class HashTableChaining:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # List of lists
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def insert(self, key, value):
        index = self._hash(key)
        bucket = self.table[index]
        
        # Check if key already exists (update)
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # Update
                return
        
        # Add new pair (collision just adds to list)
        bucket.append((key, value))
    
    def get(self, key):
        index = self._hash(key)
        bucket = self.table[index]
        
        for k, v in bucket:
            if k == key:
                return v
        return None
```

**Pros:** Simple, handles many collisions  
**Cons:** Extra memory for pointers, slower when long chains

---

## **2. OPEN ADDRESSING (Find Another Spot)**

### **How it works:**
If bucket is occupied, find next available bucket

### **A) Linear Probing**
Check next, next, next... until empty
```python
# If index 2 is full, check 3, 4, 5...
index = hash(key) % size
while table[index] is not None:
    index = (index + 1) % size  # Move to next
```

### **B) Quadratic Probing**
Check index + 1¬≤, +2¬≤, +3¬≤...
```python
i = 0
index = (hash(key) + i*i) % size
while table[index] is not None:
    i += 1
    index = (hash(key) + i*i) % size
```

### **C) Double Hashing**
Use second hash function
```python
i = 0
h1 = hash1(key)
h2 = hash2(key)
index = (h1 + i*h2) % size
while table[index] is not None:
    i += 1
    index = (h1 + i*h2) % size
```

---

## **VISUAL COMPARISON:**

### **Separate Chaining:**
```
Index 0: [A] ‚Üí [D] ‚Üí [G]  # All collisions in same bucket
Index 1: [B]
Index 2: [C]
```

### **Linear Probing:**
```
Index 0: [A]    # Original spot
Index 1: [D]    # A's collision moved here
Index 2: [G]    # D's collision moved here
Index 3: [B]
```

---

## **REAL-WORLD ANALOGY:**

### **Separate Chaining = Apartment Building**
- Same address (hash)
- Multiple apartments in same building (linked list)
- Mailman goes to building, checks each apartment

### **Open Addressing = Street Parking**
- Your spot is taken
- You drive to find next available spot
- Might be far from your preferred spot

---

## **COLLISION IMPACT ON PERFORMANCE:**

### **Good Case (Few collisions):**
```
Search time: O(1)  # Direct access
```

### **Bad Case (Many collisions - worst case):**
```
Separate Chaining: O(n)  # All items in one bucket
Linear Probing:   O(n)  # Have to search many slots
```

---

## **DEMO: Watch Collisions Happen**

```python
def demo_collisions():
    # Bad hash function (only 3 buckets)
    def bad_hash(word):
        return len(word) % 3
    
    words = ["cat", "dog", "bird", "fish", "lion", "tiger", "bear"]
    
    print("Word -> Hash -> Bucket")
    print("-" * 30)
    
    buckets = {0: [], 1: [], 2: []}
    
    for word in words:
        h = bad_hash(word)
        buckets[h].append(word)
        print(f"{word:6} -> {len(word)} % 3 = {h} -> Bucket {h}")
    
    print("\nBuckets after insertion:")
    for i in range(3):
        print(f"Bucket {i}: {buckets[i]}")

demo_collisions()
```

**Output:**
```
Word -> Hash -> Bucket
------------------------------
cat    -> 3 % 3 = 0 -> Bucket 0
dog    -> 3 % 3 = 0 -> Bucket 0  ‚Üê COLLISION!
bird   -> 4 % 3 = 1 -> Bucket 1
fish   -> 4 % 3 = 1 -> Bucket 1  ‚Üê COLLISION!
lion   -> 4 % 3 = 1 -> Bucket 1  ‚Üê COLLISION!
tiger  -> 5 % 3 = 2 -> Bucket 2
bear   -> 4 % 3 = 1 -> Bucket 1  ‚Üê COLLISION!

Buckets after insertion:
Bucket 0: ['cat', 'dog']
Bucket 1: ['bird', 'fish', 'lion', 'bear']  ‚Üê LOADED!
Bucket 2: ['tiger']
```

---

## **HOW TO REDUCE COLLISIONS:**

### **1. Good Hash Function**
```python
# Bad: Only uses first letter
bad_hash = lambda key: ord(key[0]) % 10

# Better: Uses all characters
def better_hash(key):
    total = 0
    for char in key:
        total = (total * 31 + ord(char)) % TABLE_SIZE
    return total
```

### **2. Increase Table Size**
More buckets = fewer collisions
```
10 buckets for 1000 items ‚Üí Many collisions!
1000 buckets for 1000 items ‚Üí Fewer collisions
```

### **3. Load Factor Management**
When table gets too full, resize it!
```python
load_factor = number_of_items / table_size

if load_factor > 0.7:  # Typical threshold
    resize_table()      # Double size, rehash all items
```

---

## **COLLISION IN REAL PYTHON:**

Python dictionaries use **open addressing**!
```python
# Python handles collisions automatically
d = {}
d["cat"] = "meow"
d["dog"] = "woof"  # Might collide with cat internally
# You don't see it - Python handles it!
```

---

## **FUN EXAMPLE: Birthday Paradox**

The "Birthday Problem" is a real collision example:
```python
# In a room of 23 people...
# Probability two share same birthday? 50%!
# In a room of 70 people? 99.9%!

# Similarly: With good hash function...
# Collisions happen sooner than you think!
```

---

## **QUIZ: Spot the Collisions!**

```python
# Hash function: sum of ASCII codes % 5
def hash_func(name):
    return sum(ord(c) for c in name) % 5

names = ["Sam", "Amy", "Tim", "Bob", "Kim"]

# Which pairs will collide?
print("Sam:", hash_func("Sam"))  # S(83)+a(97)+m(109)=289 %5=4
print("Amy:", hash_func("Amy"))  # A(65)+m(109)+y(121)=295 %5=0
print("Tim:", hash_func("Tim"))  # T(84)+i(105)+m(109)=298 %5=3
print("Bob:", hash_func("Bob"))  # B(66)+o(111)+b(98)=275 %5=0 ‚Üê COLLISION with Amy!
print("Kim:", hash_func("Kim"))  # K(75)+i(105)+m(109)=289 %5=4 ‚Üê COLLISION with Sam!
```

---

## **KEY TAKEAWAYS:**

1. **Collisions are inevitable** - Can't avoid them completely
2. **They slow down operations** - O(1) becomes O(n) in worst case
3. **Good design minimizes them** - Proper hash function + sizing
4. **Handling is crucial** - Choose right collision resolution method

---

## **REMEMBER:**
Collisions are like **traffic jams** in your hash table:
- üöóüöó Too many cars (keys) for roads (buckets)
- üõ£Ô∏è Solution: Build more roads (increase size) or use better routes (better hash function)
- üö¶ Or manage traffic better (chaining/probing)

**Good hash tables = Few traffic jams = Fast lookups!** üèéÔ∏èüí®