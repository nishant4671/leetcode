# **Sets in DSA: The No-Duplicates Club** üö´ü§ù

## **What is a Set?**
A **collection of UNIQUE elements** with **no duplicates** and **no guaranteed order**.

Think of it like:
- Your friend list (each friend only once)
- A bag of unique marbles (no two identical)
- A playlist without repeat songs

---

## **REAL-LIFE EXAMPLES:**
1. **Student IDs** in a class (each unique)
2. **Email addresses** in mailing list (no duplicates)
3. **Keywords** in a book (each word once for index)
4. **Social Security Numbers** (all unique)

---

## **PYTHON SET SYNTAX:**

```python
# Creating sets
empty_set = set()           # NOT {} ‚Üê that's dict!
numbers = {1, 2, 3, 4, 5}  # Curly braces, no colons
fruits = set(["apple", "banana", "orange"])  # From list

# Mixed types allowed (but must be hashable)
mixed = {1, "hello", 3.14, (1, 2)}  # Tuple is OK
# NOT allowed: {[1, 2], {1: 2}}  # Lists and dicts not hashable
```

---

## **CORE PROPERTIES:**

### **1. UNIQUENESS (No Duplicates)**
```python
numbers = {1, 2, 2, 3, 3, 3, 4}
print(numbers)  # {1, 2, 3, 4} ‚Üê Duplicates automatically removed!
```

### **2. UNORDERED**
```python
myset = {"apple", "banana", "cherry"}
print(myset)  # Could print in any order!
# Might show: {'banana', 'cherry', 'apple'}
```

### **3. MUTABLE (but elements must be immutable)**
```python
myset = {1, 2, 3}
myset.add(4)     # OK - set itself is mutable
myset.remove(2)  # OK

# But elements must be immutable:
myset.add([5, 6])  # ERROR! List is mutable
myset.add((5, 6))  # OK! Tuple is immutable
```

---

## **BASIC OPERATIONS:**

### **Add & Remove:**
```python
s = {1, 2, 3}

# Add single element
s.add(4)           # {1, 2, 3, 4}
s.add(2)           # {1, 2, 3, 4} ‚Üê No change (2 already exists)

# Add multiple elements
s.update([5, 6, 7])  # {1, 2, 3, 4, 5, 6, 7}
s.update({8, 9})     # Can add from another set

# Remove
s.remove(3)        # Remove 3, ERROR if not found
s.discard(10)      # Remove 10, NO ERROR if not found
s.pop()            # Remove random element (sets are unordered!)
s.clear()          # Remove all elements ‚Üí set()
```

### **Check Membership (FAST - O(1)):**
```python
s = {1, 2, 3, 4, 5}
print(3 in s)     # True (Instant check!)
print(10 in s)    # False
print(3 not in s) # False
```

---

## **SET OPERATIONS (Like Math Sets):**

```python
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}

# UNION (All elements from both) ‚Üí |
print(A | B)      # {1, 2, 3, 4, 5, 6, 7, 8}
print(A.union(B)) # Same

# INTERSECTION (Common elements) ‚Üí &
print(A & B)      # {4, 5}
print(A.intersection(B)) # Same

# DIFFERENCE (In A but not B) ‚Üí -
print(A - B)      # {1, 2, 3}
print(A.difference(B)) # Same

# SYMMETRIC DIFFERENCE (In either but not both) ‚Üí ^
print(A ^ B)      # {1, 2, 3, 6, 7, 8}
print(A.symmetric_difference(B)) # Same

# SUBSET & SUPERSET
C = {1, 2}
print(C <= A)     # True - C is subset of A
print(A >= C)     # True - A is superset of C
print(C < A)      # True - Proper subset (not equal)
print(A.issuperset(C)) # True
```

---

## **VISUAL SET OPERATIONS:**
```
A = {1, 2, 3}     B = {3, 4, 5}

Union (A | B):        {1, 2, 3, 4, 5}
Intersection (A & B): {3}
Difference (A - B):   {1, 2}
Difference (B - A):   {4, 5}
Symmetric (A ^ B):    {1, 2, 4, 5}
```

---

## **TIME COMPLEXITY:**

| Operation | Average | Why? |
|-----------|---------|------|
| `x in s`  | **O(1)** | Hash table lookup |
| `s.add(x)`| **O(1)** | Hash table insert |
| `s.remove(x)` | **O(1)** | Hash table delete |
| Union/Intersection | O(len(s1) + len(s2)) | Must process all elements |
| Iteration | O(n) | Must go through all |

**Much faster than lists for membership tests!**
```python
# SET (FAST)
myset = {1, 2, 3, ..., 1000000}
if 999999 in myset:  # INSTANT! O(1)

# LIST (SLOW)
mylist = [1, 2, 3, ..., 1000000]
if 999999 in mylist:  # Checks EVERY element! O(n)
```

---

## **COMMON USE CASES:**

### **1. Remove Duplicates from List**
```python
names = ["Alice", "Bob", "Alice", "Charlie", "Bob", "Alice"]
unique_names = list(set(names))  # Fastest way!
print(unique_names)  # ['Alice', 'Charlie', 'Bob'] (order may vary)
```

### **2. Membership Testing (Fast!)**
```python
# Bad with list (O(n) each check)
valid_colors = ["red", "green", "blue", "yellow"]
user_color = input("Enter color: ")
if user_color in valid_colors:  # SLOW if list is large

# Good with set (O(1) each check)
valid_colors = {"red", "green", "blue", "yellow"}
if user_color in valid_colors:  # FAST!
```

### **3. Find Common Elements**
```python
# Students in both Math and Physics classes
math_students = {"Alice", "Bob", "Charlie", "David"}
physics_students = {"Bob", "David", "Eve", "Frank"}

both = math_students & physics_students
print(both)  # {'Bob', 'David'}
```

### **4. Find Missing Elements**
```python
# What numbers from 1-10 are NOT in our data?
all_numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
our_data = {2, 4, 6, 8, 10}

missing = all_numbers - our_data
print(missing)  # {1, 3, 5, 7, 9}
```

### **5. Track Visited Items (Graph/Matrix Problems)**
```python
# Maze solving - track visited cells
visited = set()

def dfs(x, y):
    if (x, y) in visited:  # Fast check!
        return
    visited.add((x, y))    # Mark as visited
    # ... explore neighbors
```

---

## **FROZENSET: Immutable Set**

```python
# Regular set is mutable (can add/remove)
s = {1, 2, 3}
s.add(4)  # OK

# Frozenset is immutable (can't modify)
fs = frozenset([1, 2, 3])
# fs.add(4)  # ERROR! Cannot modify

# Use case: As dictionary key (regular sets can't be keys)
dict_with_frozenset = {
    frozenset([1, 2]): "value1",
    frozenset([3, 4]): "value2"
}
```

---

## **PROBLEM-SOLVING PATTERNS:**

### **Pattern 1: Two-Sum with Set**
```python
def has_pair_with_sum(numbers, target):
    seen = set()
    for num in numbers:
        complement = target - num
        if complement in seen:  # O(1) check!
            return True
        seen.add(num)
    return False

print(has_pair_with_sum([1, 2, 3, 4, 5], 8))  # True (3+5)
```

### **Pattern 2: Find First Repeating Character**
```python
def first_repeating_char(s):
    seen = set()
    for char in s:
        if char in seen:
            return char
        seen.add(char)
    return None

print(first_repeating_char("abcdefc"))  # 'c'
```

### **Pattern 3: Check if All Characters Unique**
```python
def all_unique(s):
    return len(set(s)) == len(s)

print(all_unique("hello"))   # False (l repeats)
print(all_unique("world"))   # True
```

### **Pattern 4: Find Missing Number**
```python
def find_missing(nums, n):
    # Numbers should be 1 to n, one is missing
    full_set = set(range(1, n+1))
    num_set = set(nums)
    missing = full_set - num_set
    return missing.pop() if missing else None

print(find_missing([1, 2, 4, 5], 5))  # 3
```

---

## **SET vs LIST vs DICTIONARY:**

| Feature | Set | List | Dictionary |
|---------|-----|------|------------|
| Duplicates | ‚ùå No | ‚úÖ Yes | Keys: ‚ùå No, Values: ‚úÖ Yes |
| Order | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes (Python 3.7+) |
| Index Access | ‚ùå No | ‚úÖ Yes (my_list[0]) | ‚úÖ Yes (by key) |
| Membership Test | ‚úÖ O(1) (Fast) | ‚ùå O(n) (Slow) | ‚úÖ O(1) (by key) |
| Mutable | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| Elements | Immutable only | Anything | Keys: Immutable, Values: Anything |

---

## **COMMON MISTAKES:**

```python
# 1. Empty set wrong way
wrong = {}           # This is a DICT, not set!
correct = set()      # This is empty set

# 2. Trying to access by index
s = {1, 2, 3}
# print(s[0])        # ERROR! Sets don't support indexing

# 3. Sets of mutable items
# s = {[1, 2], [3, 4]}  # ERROR! Lists are mutable
s = {(1, 2), (3, 4)}    # OK! Tuples are immutable

# 4. Assuming order
s = {"apple", "banana", "cherry"}
for fruit in s:
    print(fruit)  # Could be any order!

# 5. Modifying while iterating
s = {1, 2, 3, 4, 5}
# for x in s:
#     if x % 2 == 0:
#         s.remove(x)  # ERROR! Don't modify during iteration
```

---

## **QUICK CHEAT SHEET:**

```python
# Creation
s = {1, 2, 3}
s = set([1, 2, 3])

# Add/Remove
s.add(x)        # Add one
s.update([x, y])# Add multiple
s.remove(x)     # Remove, error if missing
s.discard(x)    # Remove, no error
s.pop()         # Remove random

# Operations
A | B   # Union
A & B   # Intersection  
A - B   # Difference
A ^ B   # Symmetric difference

# Checks
x in s          # Membership
A <= B          # Subset
A.issubset(B)   # Same
len(s)          # Size

# Conversion
list(s)         # Set to list
tuple(s)        # Set to tuple
```

---

## **REMEMBER:**
- **Set** = **Unique** + **Unordered** + **Fast membership**
- Use when you need: "Have I seen this before?" or "Is this in the collection?"
- Perfect for removing duplicates and fast lookups!

Think of sets as your **personal bouncer** at a club: 
- Checks if someone's already inside (fast!)
- Never lets duplicates enter! üö´üëØ